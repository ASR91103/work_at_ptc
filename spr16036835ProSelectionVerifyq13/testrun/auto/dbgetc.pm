# 09-Jun-06 L-01-10 SJB $$1 L-01-10 changes
# 13-Sep-06 L-01-16 SJB $$2 Skip .dmp files.
# 07-Jun-10 L-05-24 mdabhi $$3 Check the existance of OL PVS file.
# 12-Aug-13 P-20-36 SJB $$4 Skip THA (foreign CAD) files.
# 15-Aug-13 P-20-36 SJB $$5 Skip Python error from nCode version 9 libraries.
# 21-Aug-13 P-20-36 SJB $$6 Skip more THA files.
# 26-Aug-13 P-20-37 SJB $$7 Skip more THA files.
# 19-Sep-13 P-20-39 PSG $$8 Undo ##5.
# INI file parser 
package dbgetc;  # assumes dbgetc.pm

use File::Basename;
use Cwd;

use strict;
BEGIN {
    use Exporter   ();
    use vars       qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
    
    @ISA         = qw(Exporter);
    @EXPORT      = qw( $debug $cur_dir $sep @SkipExt @MustExistExt &SetDiffArrays 
                       &GetFN &GetFtype &GetFdir &eprint &dprint &ecat &GetEnvVars  
                       &SysCmd &Replace &GetLSMValues &MeshOK &MeshGeomOK &MeshGeomSKIP 
                       &DVCheckOK &FileOK );
    
    %EXPORT_TAGS = ( );     # eg: TAG => [ qw!name1 name2! ],

    # your exported package globals go here,
    # as well as any optionally exported functions
    @EXPORT_OK   = ();
        
}
use vars   @EXPORT,@EXPORT_OK;

select(STDERR);
$| = 1;
select(STDOUT);
$| = 1;

### Global Variables ###
$sep = '\\' if ( $ENV{'OS_TYPE'} eq 'NT' );
$sep = '/'  if ( $ENV{'OS_TYPE'} eq 'UNIX' );
$cur_dir=cwd();
$cur_dir =~ tr/\//\\/ if ( $ENV{'OS_TYPE'} eq 'NT' );



##############################################################################################################
# RECIEVES:  NOTHING
# RETURNS:   NOTHING
# PURPOSE:   Set which files are to be skipped and which files must exist when running a regression.
##############################################################################################################
sub SetDiffArrays {
   
    no strict 'vars';
    my $test_type = shift;

    #If exist in Std, Don't Diff and Don't check for existance  
    @SkipExt = ( '\.\d+$',  '\.mbk$', '\.mba$', '\.pej$', '\.prt$', '\.asm$', '\.txt$', '\.nme$',   '\.n\d+$',
                 '\.pro$', '\.inf$', '\.fnf$', '\.fui$', '\.info$',  'objname$', 'core$', '^mecbatch',
                 '\.dat$',  '\.idx$', '\.da6$', '\.id6$', '\.tld$',   '\.mdcfg$', '\.orig$', '\.pnu$', 
                 '\.resdiff$', '\.ter$', 'mechevnt$', 'resource\.qat$', 'autogem\.qat$', '\.neu$', '~$',
                 '\.rst$', '\.log$', '^#', '\.scr$',  '^_', '\.csv$', '\.dmp$', '\.xpr$', '\.creo',
                 '\.CATPart$', '\.CATProduct$', '\.par$',  '\.ipt$', '\.iam$', '\.SLDPRT$', '\.SLDASM$',
                 '\.sldprt$', '\.sldasm$', '\.cgr$',  '\.model$', '\.CATPART$', '\.CATPRODUCT$' );


    #If exist in Std, must be generated by run but not diffed    
    @MustExistExt = ( '\.err$',  '\.rpt$', '\.ol$', '\.pvs$', '\.stt$', '\.dia$', '\.pas$', '\.coe$', '\.mor$', '\.buc$',
                      '\.skip$', '\.agb$', '\.agm$', '\.da2$', '\.id2$', '\.tld$', '\.bak$',
                      '\.coe$',  '\.rst$', '\.buc$', '\.dpi$', '\.unv$', '\.scr$', '\.cfg$', '\.igs$',
                      '\.igl$',  '\.dxf$', '\.vda$', '\.vdl$',   '\.o$', '\.sim$', '\.siz$', '\.rwd$', 
                      'mmenglog$', 'mmoptlog$', '\.solution$', '\.fatigue\d{2,}$', '\.mcd$', '\.mmp$', 
                      '\.mma$', '\.dbid\d+_Ptrans', '\.avg$', '\.xml$', '\.css$', '\.usr$',
                      # Print Files to skip
                      '\.djt$',  '\.dj5$', '\.dj6$', '\.tif$', '\.pjt$', '\.px3$', '\.dj87$', '\.dj16$',
                      '\.jpg$',  '\.pjx$', '\.hpg$',  '\.ps$', '\.eps$', '\.bmp$', '\.gif$',  '\.mpg$' ,
                      '\.htm$', '\.html$', '\.wrl$');


    ### For Amit's ProE to mdb conversion changes ###
    unshift(@SkipExt, ('\.mnf$','\.mnl$', '\.ids$') );

    if ( $test_type eq 'QATitg_eng' or $test_type eq 'QATitgeng_pp' ) {
        unshift(@SkipExt, ('\.mdb$', '\.mda$') );
    } else {
        unshift(@MustExistExt, ('\.mdb$', '\.mda$') );
    }
}


#************************************************
# Get file name from full path
#************************************************
sub GetFN{

 my $path=shift;

 my ($name,$dir,$type) = fileparse($path,'\..*');
 return "$name$type";

};


#************************************************
# Get file type from full path
#************************************************
sub GetFtype {

 my $path=shift;

 my ($name,$dir,$type) = fileparse($path,'\..*');
 $type=substr($type,1);
 return $type;

};


#************************************************
# Get Directory
#************************************************
sub GetFdir {

 my $path=shift;

 my ($name,$dir,$type) = fileparse($path,'\..*');
 return $dir;

};


#************************************************
# Print line to sim_failure.dat
#************************************************
sub eprint {

  my $line=shift;
  dprint("\t$line");
  
  open DBG, ">>$cur_dir$sep"."sim_fail.dat";
  open STDERROUT, ">>$cur_dir$sep"."std.err";
  
  print STDERR "$line\n";
  print STDERROUT "$line\n";
  print DBG "$line\n";
  
  close STDERROUT;
  close DBG;
}


#************************************************
# CAT file to sim_failure.dat
#************************************************
sub ecat {
    my $file=shift;
    open FL, "<$file";
    open DBG, ">>$cur_dir$sep"."sim_fail.dat";

    while (<FL>) {
        print DBG "$_\n";
        print STDERR "$_\n";
    }

    close DBG;
    close FL;
}


#************************************************
# debug print
#************************************************
sub dprint {
    my $line=shift;
    print "$line\n" if ($debug == 1);
    open CMD, ">>$cur_dir$sep"."command.log";
    print CMD "$line\n";
    close CMD;
};


######################################################
# RECEIVES:  Array of System Commands
# RETURNS:   Nothing
# PURPOSE:   Execute System commands with a time out function
######################################################
sub SysCmd {

    my ($Cmd)  = @_;
    dprint("\t$Cmd");
    my $stat = system("$Cmd");
    return $stat;
}


######################################################
# RECIEVES: 2 File names and then at least 1 or more 
#           pairs of strings.
#           ex:  Replace($File1, $File2, $StringA1, $StringA2);
# RETURNS:  NOTHING
# PURPOSE:  In the 1st File replacing the first string 
#           in a pair with the second string and copy the 
#           result to the second file name. 
#
#           Like 'sed' does but with multiple string pairs 
#           and an echo to dprint for each replacement pair.
############################################################
sub Replace {
    use strict;
    my ($i, $Line, $Key);
    my $TEMPFILE = 'TempFile.txt';
    
    my $OldFile = shift;
    my $NewFile = shift;
    my %replace = @_;
    my @Keys    = keys(%replace);
    my @Values  = values(%replace);
    
    if ( @_ < 2 ){
        eprint("Replace Command Arguments not correct");
        exit -1;
    }

    if ( -f $NewFile and $NewFile ne $OldFile){
        eprint("The File $NewFile already exists"); 
        exit -1;
    }


    if ( !-f $OldFile ){
        eprint("Cant find $OldFile to replace the strings @Keys");
        exit -1;
    }
    
    #Prints out function changes
    foreach $Key ( @Keys ) {
        dprint("\tReplacing \"$Key\" with \"$replace{$Key}\" in $NewFile");
    }

    #If target and source files are the same
    if ($OldFile eq $NewFile){
         $NewFile     = $TEMPFILE
    }
    
    #Replaces strings
    open(OLDFILE, "<$OldFile") or die("$!");
    open(NEWFILE, ">$NewFile") or die("$!");
    foreach $Line (<OLDFILE>) {
        chomp $Line;
        foreach $Key ( @Keys ) { 
                $Line =~ s/$Key/$replace{$Key}/g;
        }
        print NEWFILE "$Line\n";
    }
    close(OLDFILE);
    close(NEWFILE);

    #If the target and source are the same
    if ( $NewFile eq $TEMPFILE ){
        unlink($OldFile);
        rename($TEMPFILE,$OldFile) or eprint("Could not move create $OldFile");
    }
}

#############################################################
# RECIEVES: File Name and a Array of Strings
# RETURNS:  Nothing
# PURPOSE:  Returns array of lsm file values for the argument strings
#############################################################
sub GetLSMValues {
    use strict;
    my ($Line, $i, @LineElements, @Values);
    
    my $InFile  = shift;
    my @Keys  = @_;
    
    if (not -f $InFile){
        eprint("MISSING FILE: $InFile");
        exit(1);
    }

    open(INFILE, "<$InFile") or die("$!");
    my @File = <INFILE>;
    close(INFILE);
    KEY: for $i ( 0 .. $#Keys ) {
        my $Match = $Keys[$i];
        foreach $Line (@File) {
            chomp $Line;
            if ($Line =~ /^$Match\s/) {
                @LineElements = split(' ', $Line);
                $Values[$i]   = $LineElements['1'];
                next KEY;
            }
        }
    }

    # Make sure all Keys have a corresponding Value
    for $i ( 0 .. $#Keys ){
        eprint("ERROR: \'$Keys[$i]\' was not found in $InFile") if ( not defined $Values[$i] );
    }
    return @Values;
}



#############################################################
# RECEIVES: Nothing
# RETURNS:  0 if Geom is not valid or 1 if Geom valid 
# PURPOSE:  Checks for 'autogem.qat' file to see if model
#           has valid geometry to mesh.
#############################################################
sub MeshGeomOK {
    use strict;

    my $RunDir        = shift;
    my $GeomOK        = 0;
    my $GeomSKIP      = 0;
    my $ModelFinished = 0;
    my $AutoGem       = $RunDir . $sep . 'autogem.qat';
    my $Switch;
    
    if ( open (AUTOGEM_FILE, "<$AutoGem") ) {
        my @FileLines = <AUTOGEM_FILE>;
        close(AUTOGEM_FILE);
        
        # If not matched before last line Print Failed
        my $i;
        for $i  ( 0 .. $#FileLines ) {
            
            if ( $FileLines[$i] =~ /AV_QA_CHECK_GEOM\:\s+PASS/ ){
                $GeomOK = 1;
            }
            
            if ( $FileLines[$i] =~ /.\s+Finished\s+model\s+/ ) {
                $ModelFinished = 1; 
                last;
            }
            
            ### Check to see if Geom Check skipped ###
            if ( $FileLines[$i] =~ /AV_QA_CHECK_GEOM\:\s+SKIP/ ){
                $GeomSKIP = 1;
                last;
            }
        }
    } else {
        eprint("MISSING FILE: autogem.qat NOT GENERATED");
    }
    
    if ( $GeomOK and $ModelFinished ) {
        dprint("\tPASSED QA_GEOM_CHECK");
        $Switch = 1;
    } elsif ( $GeomSKIP ) {
        dprint("\tSKIPPED QA_GEOM_CHECK");
        $Switch = 1;
    } else {
        eprint("ERROR: FAILED QA_GEOM_CHECK");
        $Switch = 0;
    }
        
    return $Switch;
}


#############################################################
# RECEIVES: Nothing
# RETURNS:  Nothing 
# PURPOSE:  Creates autogem.qat file with skip message
#############################################################
sub MeshGeomSKIP {

    use strict;
    my $AutoGem  = 'autogem.qat';

    open (AUTOGEM_FILE, ">$AutoGem"); 
    print AUTOGEM_FILE "AV_QA_CHECK_GEOM: SKIP\n";
    close(AUTOGEM_FILE);
}


#############################################################
# RECIEVES: Nothing
# RETURNS:  0 if Meshing was successful or 1 if Meshing failed
# PURPOSE:  Checks for 'autogem.qat' file to see if model
#           meshed successfully.
#############################################################
sub MeshOK {
    use strict;
    my $RunDir = shift;
    my $Switch = 0;
    my $AutoGem = $RunDir . $sep . 'autogem.qat';
    
    if ( open (AUTOGEM_FILE, "<$AutoGem") ) {
        my @FileLines = <AUTOGEM_FILE>;
        close(AUTOGEM_FILE);
        
        # If not matched before last Failed
        my $i;
        for $i  ( 0 .. $#FileLines ) {
            if ( $FileLines[$i] =~ /\*\*\*INFO\:\s+AUTOGEM\:\s+PASS/ ){
                dprint("\tAUTOGEM Mesh Successful");
                $Switch = 1;
                last;
            }
        }
    } else {
        eprint("MISSING FILE: autogem.qat file was not generated");
    }
    
    eprint("AUTOGEM Mesh FAILED") if ( ! "$Switch" );
    
    return $Switch;
}

#############################################################
# RECIEVES: Name of DV output file
# RETURNS:  0 if Design Variable Check was successful or 1 if 
#           Design Variable Check failed
# PURPOSE:  Checks for 'autogem.qat' file to see if model
#           meshed successfully.
#############################################################
sub DVCheckOK {
    use strict;
    my $DV_File = shift;
    my $Switch = 1;
    
    if ( open (DV_OUT_FILE, "<$DV_File") ) {
        my @FileLines = <DV_OUT_FILE>;
        close(DV_OUT_FILE);
        
        # If not matched before last line Print Failed
        my $i;
        for $i  ( 0 .. $#FileLines ) {
            if ( $FileLines[$i] =~ /SUCCESSFUL\s+0/ ){
                $Switch = 0;
                last;
            }
        }
    } else {
        eprint("ERROR: The File \"$DV_File\" was not generated");
    }

    if ( "$Switch" ){
        dprint("\tDV Check Successful");
    } else {
        eprint("DV Check FAILED");
    }


    return $Switch;
}

#############################################################
# RECIEVES: File Name and a Array of Strings
# RETURNS:  Nothing
# PURPOSE:  Returns array of lsm file values for the argument strings
#############################################################
sub GetEnvVars {
    
    use strict;
    my $EnvFile  = shift;
    
    if (!-f $EnvFile){
        dprint("\tNo $EnvFile file");
        return;
    }

    open(ENVFILE, "<$EnvFile") or die("open: $!");
    foreach (<ENVFILE>) {
        next if /^#/;
        chomp;
        s/^\s+//;
        s/\s+/ /;
        m/(\S+)\s+(.+)/;
        my $EnvVar = $1;
        my $Value = $2;
        $ENV{$EnvVar}  =  "$Value";
    }
    dprint("\tLoaded $EnvFile file");
    close(ENVFILE);
    return ;
}

#############################################################
# RECIEVES: File Name and option string
# RETURNS:  true or false
# PURPOSE:  Workaround for a Hamilton C shell bug on Installs
#           where the file created can not be seen right away
#############################################################
sub FileOK {

    my $Option = shift;
    my $File   = shift;
    my $i;

    for ( $i = 0; $i <= $ENV{SIM_TIMEOUT} / 10 ; $i++ )
    {
        return 1 if ( -f "$File" and $Option == '-f' );
        return 1 if ( -s "$File" and $Option == '-s' );
        return 1 if ( -e "$File" and $Option == '-e' );
        return 1 if ( -d "$File" and $Option == '-d' );
        sleep(1);
    }
    return 0;
}

#############################################################

END { }       # module clean-up code here (global destructor)

1; #Important
